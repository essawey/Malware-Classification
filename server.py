# %pip install pandas==2.1.2
# %pip install numpy==1.26.2
# %pip install scikit-learn==1.2.2
# %pip install Flask==3.0.0

import numpy as np
import pickle
import gdown
import json
import os
import wandb
from monitoring import log_predictions, save_error_rate
from datetime import datetime
from flask import Flask, request, jsonify, send_file, send_from_directory

now = datetime.now()

app = Flask(__name__)


print("\033[94mSERVER\033[0m: Downloading the models")
if not os.path.exists("./top_k_features_RFC.pkl"):
    gdown.download(id = "1-3qqxJuxzEdLj0EQDkQe5yQDSJhLr4YO", output = "top_k_features_RFC.pkl", quiet=True)

if not os.path.exists("./RFC_top_k.pkl"):
    gdown.download(id = "1tR6iYm-M29bfhkigmH7P3MPX2LxHVky2", output = "RFC_top_k.pkl", quiet=True)

if not os.path.exists("./RFC_pca.pkl"):
    gdown.download(id = "1-KYf36jOLGaaNZd0o8zIcgE7dMdkO2OD", output = "RFC_pca.pkl", quiet=True)

if not os.path.exists("./pca_model.pkl"):
    gdown.download(id = "1-CicPQi22EB3JJcN3B_JJsNROtwe6Mfm", output = "pca_model.pkl", quiet=True)

if not os.path.exists("./labelSet.json"):
    gdown.download(id = "1GzfZAb0k1mMa8iaRCJO3Q2TBPC1Yfkzm", output = "labelSet.json", quiet=True)


# Loading the Random Forest Classification and Principal Component Analysis model
print("\033[94mSERVER\033[0m: Loading the models")

with open('RFC_pca.pkl', 'rb') as file:
    RFC_pca = pickle.load(file)

with open('pca_model.pkl', 'rb') as file:
    pca_model = pickle.load(file)

with open('RFC_top_k.pkl', 'rb') as file:
    RFC_top_k = pickle.load(file)

with open('top_k_features_RFC.pkl', 'rb') as file:
    top_k_features_RFC = pickle.load(file)

with open('labelSet.json', 'r') as file:
    labelSet = json.load(file)


labelSet = {v: k for k, v in labelSet.items()}

@app.route('/', methods=['GET'])
def help():
    return send_from_directory('templates', 'index.html')


# Developing of an API that can receive POST requests  
@app.route('/predict_PCA', methods=['POST'])
def predict_PCA():

    # Accessing the client sent JSON
    client_data:dict = request.get_json(force=True)

    # Chaning the prediction to the model data type (numpy.array)
    X:list[int] = client_data['X']
    RowNumber:int = client_data['RowNumber']
    GroundTruth:str = client_data['GroundTruth']

    X:np.array = np.array(X)
    X_PCA = pca_model.transform(X)

    # Passing the X to the .predict function
    prediction = RFC_pca.predict(X_PCA)
    prediction = prediction[0]

    prediction_dict = {
        'prediction': labelSet[prediction],
    }

    if labelSet[prediction] != GroundTruth:
        save_error_rate()

    table = log_predictions([
        RowNumber,
        "PCA and RFC",
        labelSet[prediction],
        GroundTruth
    ])
        
    return jsonify(prediction_dict)


@app.route('/predict_top_K', methods=['POST'])
def predict_top_K():

    # Accessing the client sent JSON
    client_data:dict = request.get_json(force=True)

    # Chaning the prediction to the model data type (numpy.array)
    X:list[int] = client_data['X']
    RowNumber:int = client_data['RowNumber']
    GroundTruth:str = client_data['GroundTruth']


    X:np.array = np.array(X)
    top_k_features_X= X[:, top_k_features_RFC]

    # Passing the X to the .predict function
    prediction = RFC_top_k.predict(top_k_features_X)
    prediction = prediction[0]


    prediction_dict = {
        'prediction': labelSet[prediction],  
    }

    if labelSet[prediction] != GroundTruth:
        save_error_rate()

    table = log_predictions([
        RowNumber,
        "Top K and RFC",
        labelSet[prediction],
        GroundTruth
    ])

    return jsonify(prediction_dict)

@app.route('/get_predictions', methods=['GET'])
def get_predictions_csv():

    file_path = 'predictions.csv'
    if os.path.exists(file_path):
        return send_file(file_path, as_attachment=True)
    else:
        return jsonify({'prediction': 'File not found'}), 404

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
